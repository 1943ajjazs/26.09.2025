# 26.09.2025
Козуб Алексей УИБО-12-24


Куча — это специализированная структура данных, обычно реализуемая в виде полного бинарного дерева с дополнительным инвариантом: для мин-кучи значение в любом узле не больше значений его детей (для макс-кучи — не меньше). В практических реализациях двоичная куча хранится в виде массива, где для узла с индексом i дети находятся по индексам 2*i+1 и 2*i+2, что даёт компактное представление и эффективные операции push/pop/peek с логарифмической сложностью на вставку/удаление и константной — на просмотр минимума/максимума. В Python для двоичной кучи используется модуль heapq (реализует мин-кучу): heapq.heapify(list) — превращает список в кучу, heapq.heappush(heap, x) — вставляет элемент, heapq.heappop(heap) — извлекает минимум; для макс-кучи обычно инвертируют знаки ключей. Если требуется своя реализация (например, чтобы хранить дополнительные данные или поддерживать decrease_key), реализуют класс с методами _sift_up/_sift_down (heapify up/down). Биномиальная куча и куча Фибоначчи — более сложные структуры: биномиальная куча представляет собой набор биномиальных деревьев (каждое дерево размера 2^k) и удобна для эффективного слияния (union), а фибоначчиева куча даёт лучшие амортизированные оценки операций decrease_key и merge — эти структуры обычно реализуют в виде классов с методами insert, merge/union, extract_min, decrease_key и внутренними списками корней; в Python подобных структур в стандартной библиотеке нет, поэтому при необходимости используют сторонние реализации или пишут собственные классы. Примеры (Python):

# Пример: heapq — мин-куча
import heapq
a = [8, 3, 5, 1, 6, 2, 4, 7]
heapq.heapify(a)           # превращаем список в кучу
heapq.heappush(a, 0)       # добавляем 0
minimum = heapq.heappop(a) # извлекаем минимальное значение

# Макс-куча через инверсию
data = [5, 1, 7]
maxh = [-x for x in data]
heapq.heapify(maxh)
heapq.heappush(maxh, -10)
max_val = -heapq.heappop(maxh)

Если нужна своя двоичная куча с decrease_key, типичный шаблон — массив heap + индексы позиций элементов + реализация _sift_up/_sift_down. Для биномиальных/Фибоначчиевых куч приводят интерфейс-заготовки с методами insert/merge/extract_min/decrease_key, поскольку их реализация гораздо сложнее и требует управления списками детей/сиблингов и степени узлов.



Хеш-таблица — ассоциативный контейнер «ключ → значение», основной принцип которого: хеш-функция переводит ключ в индекс массива (bucket), что позволяет в среднем получать доступ, вставку и удаление за O(1). В Python наиболее распространённый и эффективный способ — встроенный dict: вставка d[key] = value, чтение v = d[key] или v = d.get(key, default), проверка наличия ключа — key in d. Ключи у dict должны быть хешируемыми (неизменяемые типы: строки, числа, кортежи и т.д.), а значениями могут быть любые объекты. При коллизиях (разные ключи дают одинаковый индекс) применяют два основных подхода: цепочки (в одной корзине хранится список/связный список пар) или открытое адресование (линейное/квадратичное пробирование, двойное хеширование). В учебных примерах часто приводят реализацию с цепочками — она проста и надёжна: фиксированный массив списков, собственная хеш-функция и методы put/get/remove. Пример ручной реализации с методом цепочек:

class HashTable:
    def __init__(self, size=16):
        self.size = size
        self.table = [[] for _ in range(size)]  # chaining: список бакетов

    def _hash(self, key):
        # простая функция: сумма кодов символов (для учебных целей)
        return sum(ord(c) for c in str(key)) % self.size

    def put(self, key, value):
        idx = self._hash(key)
        bucket = self.table[idx]
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)  # обновление
                return
        bucket.append((key, value))     # вставка

    def get(self, key):
        idx = self._hash(key)
        for k, v in self.table[idx]:
            if k == key:
                return v
        raise KeyError(key)

    def remove(self, key):
        idx = self._hash(key)
        bucket = self.table[idx]
        for i, (k, _) in enumerate(bucket):
            if k == key:
                bucket.pop(i)
                return
        raise KeyError(key)



Альтернативно, при использовании открытой адресации (линейное пробирование) вместо списка в каждой ячейке хранится одно значение, и при коллизии ищут следующую свободную ячейку; это усложняет операции удаления (нужны маркеры «удалённый слот») и перераспределение при расширении. В реальных задачах в Python рекомендуется пользоваться встроенным dict (оптимизирован и безопасен), а при образовательных целях — писать простую реализацию методом цепочек, как показано выше, чтобы наглядно изучить хеш-функции, разрешение коллизий и рехеширование (увеличение массива и перехеширование элементов).
